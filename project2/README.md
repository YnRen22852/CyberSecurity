## 基于数字水印的图片泄露检测

### 一、实验方法

1. 采用 **基于最低有效位（LSB）** 的图像水印嵌入算法
2. 实现 **水印提取算法** 并验证其正确性
3. 测试 **水印系统对常见图像处理操作的鲁棒性**

---

### 二、实现原理

#### 1. 水印嵌入原理

LSB 技术利用人眼对像素最低有效位（Least Significant Bit）不敏感的特性，将水印信息嵌入蓝色通道的最低位中。

**实现流程：**

(1) **文本转二进制**

```python
def tobits(text):
    bits = []
    for char in text:
        b = bin(ord(char))[2:].rjust(8, '0')
        bits.extend([int(bit) for bit in b])
    return bits
```

* 将每个字符转为 **8位二进制**，不足补0
* 将所有字符的比特顺序连接成水印比特流

(2) **添加长度信息**

```python
length_bits = [int(b) for b in bin(length)[2:].rjust(8, '0')]
full_bits = length_bits + bits
```

* 在比特流开头添加 **8位长度信息**，方便提取时准确定位水印

(3) **嵌入水印**

```python
b, g, r = cv2.split(img.copy())
flat = b.flatten()
flat = (flat & 0xFE) | np.array(all_bits, dtype=np.uint8)
```

* 分离蓝色通道（因人眼对蓝色最不敏感）
* 位操作 `(AND 0xFE)` 将最低位清零
* 将水印比特通过 `(OR)` 操作写入最低位
* 重组图像通道并保存

---

#### 2. 水印提取原理

(1) **提取LSB比特**

```python
b = img[:, :, 0].flatten()
bits = [int(bit) for bit in (b & 1)]
```

* 分离蓝色通道并展平
* 提取最低有效位 `(AND 1)`

(2) **解析长度信息**

```python
length = int(''.join(str(bit) for bit in bits[:8]), 2)
text_bits = bits[8:8+length]
```

* 前8位为水印长度信息
* 根据长度提取对应比特流

(3) **比特流转文本**

```python
for i in range(0, len(bits), 8):
    byte = bits[i:i+8]
    val = int(''.join(str(b) for b in byte), 2)
    word.append(chr(val))
```

* 每8位转为一个字符
* 组合形成原始水印文本

---

### 三、鲁棒性测试

| 测试类型  | 实现方式              | 目的          |
| ----- | ----------------- | ----------- |
| 翻转测试  | 提取前将图像翻转回原方向      | 验证对几何变换的抵抗力 |
| 平移测试  | 右移50像素，下移30像素     | 测试位置变化的鲁棒性  |
| 截取测试  | 截取中心 250×300 像素区域 | 测试部分缺失的影响   |
| 对比度调整 | 对比度 ×1.5          | 验证颜色调整的抵抗力  |
| 噪声攻击  | 添加高斯噪声（均值0，σ=25）  | 模拟传输噪声干扰    |

---

### 四、实验结果

* 提取的文本水印与嵌入的水印 **完全一致**
* **翻转测试**：可正常提取水印
* **平移测试**：水印可提取，说明位置变化影响不大
* **截取测试**：由于水印嵌入在左上角，截取中心部分依然成功提取
* **对比度调整与轻度噪声**：水印仍可正确提取，表明系统对轻度颜色和噪声变化有较强鲁棒性

---
