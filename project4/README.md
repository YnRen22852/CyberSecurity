## SM3 软件实现与优化

### 一、SM3 算法实现

#### 1. 算法流程

1. **消息填充**

   * 先在消息末尾添加一个 `1` 位
   * 再添加若干个 `0` 位
   * 最后添加 64 位的原始消息长度
   * 使最终长度变为 512 的倍数

2. **消息扩展**

   * 将填充后的消息分为 512 位的块
   * 每个 512 位块扩展为 132 个 32 位字

3. **压缩函数**

   * 用初始向量 IV 与消息块进行非线性变换压缩
   * 共 32 轮迭代，每轮使用扩展后的消息字和常量混合运算

4. **迭代运算**

   * 将当前压缩结果与前一结果相加，作为下一次输入
   * 直至所有消息块处理完毕

5. **输出哈希值**

   * 最终得到 256 位的哈希值

---

### 二、优化思路与原理

1. **循环展开 (Loop Unrolling)**

   * 消息扩展与压缩函数循环展开 4 次
   * 每次计算 4 个 W 值 / 处理 4 轮运算
   * 减少循环控制开销，提升指令级并行度

2. **寄存器优化**

   * 状态变量 (A-H) 全部存放在局部寄存器
   * 避免频繁访问内存

3. **内存访问优化**

   * 使用固定大小缓冲区（64 字节）
   * 避免动态分配内存
   * 使用 `memcpy` 替代复杂的向量操作
   * 减少缓存未命中率

4. **指令级并行**

   * 调整计算顺序，使独立指令并行执行
   * 消息扩展阶段并行计算 W1 数组
   * 消除数据依赖

5. **宏函数优化**

   * 核心操作（ROL、FF、GG）使用宏定义
   * 避免函数调用开销

6. **条件分支优化**

   * 将 0–15 轮与 16–63 轮分开处理
   * 使用常量传播优化 Tj 计算
   * 降低分支预测失败率

7. **内存布局优化**

   * 状态变量连续存储
   * 缓冲区按 64 字节对齐

---

### 三、实验结果（节选）

```
数据大小: 1 MB
迭代次数: 100
总时间: 2350.500 ms
平均时间: 23.505 ms
吞吐量: 42.55 MB/s
```

优化后性能显著提升。

---

## 四、长度扩展攻击（Length Extension Attack）

### 1. 攻击原理

* **Merkle-Damgård 结构特性**

  * 将消息分成固定大小的块（SM3 为 64 字节）
  * 每块处理依赖前一块的输出状态
  * 最终哈希值即最后一个状态

* **攻击流程**

  1. 攻击者已知原消息 `M1` 的哈希值 `H(M1)`
  2. 知道 `M1` 的长度
  3. 构造新消息 `M2 = M1 || pad || M'`
  4. 直接计算 `H(M2)` 而无需知道 `M1` 内容

---

### 2. 实验结果

```
原始消息: "This is a secret message"
原始哈希: 7a1e6c0a...
伪造消息: [M1的填充] + "&admin=true"
伪造哈希: 8e9f7a6b...
真实扩展消息哈希: 8e9f7a6b...

攻击成功！伪造哈希与真实哈希匹配
```

---

## 五、Merkle 树与证明

### 1. RFC6962 规范要点

* **哈希前缀**

  * 叶子节点：`HASH(0x00 || data)`
  * 内部节点：`HASH(0x01 || left_hash || right_hash)`

* **树结构**

  * 二叉树，叶子为实际数据
  * 树大小为 2 的幂（不足补齐）
  * 叶子按顺序存储

* **证明类型**

  * 存在性证明（Inclusion Proof）
  * 不存在性证明（Exclusion Proof）

---

### 2. 实现功能

* **Merkle 树构建**

  * 支持任意数量叶子（含 10 万节点）
  * 自动计算高度与根哈希

* **存在性证明**

  * `get_inclusion_proof()` 获取路径
  * `verify_inclusion()` 验证路径

* **不存在性证明**

  * `get_exclusion_proof()` 获取前驱/后继节点证明
  * `verify_exclusion()` 验证目标节点应位于两者之间

---
