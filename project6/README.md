## Google Password Checkup 验证

### 基于 DDH 的私密交集求和协议（DDH-based Private Intersection-Sum Protocol）

参考论文：[ePrint 2019/723](https://eprint.iacr.org/2019/723.pdf) 第 3.1 节（Figure 2）

---

### 1. 协议目标

该协议旨在 **在不泄露非交集信息的前提下**，计算两个参与方集合的交集元素对应数值的总和：

* **参与方 P1**：持有标识符集合
  $V = \{ v_1, v_2, ..., v_{m_1} \}$
* **参与方 P2**：持有带权重（数值）的标识符对
  $W = \{ (w_i, t_i) \}$，其中 $t_i$ 为数值（金额、分数等）

**输出目标**：

* **P2** 获得交集元素对应的 $t_i$ 总和
* **隐私要求**：

  * P1 不得获知 P2 的任何数据
  * P2 不得获知交集以外的元素

---

### 2. 密码学基础与工具

#### 2.1 群与哈希函数

* 群 $G$：素数阶群，支持安全的指数运算（椭圆曲线或 $\mathbb{Z}_p^*$）
* 哈希函数 $H: \mathcal{U} \to G$：将标识符映射为群元素，用于一致性匹配，建模为随机预言机

#### 2.2 DDH 假设

* **作用**：确保对非交集项的三次指数值 $H(v)^{k_1 k_2}$ 无法恢复原值或建立关联

#### 2.3 加法同态加密（AHE）

* 如 Paillier 系统，支持：

  $$
  AEnc(m_1) \oplus AEnc(m_2) = AEnc(m_1 + m_2)
  $$
* 用于在不解密的情况下累加多个 $t_i$

---

### 3. 协议输入

* **P1**：

  $$
  V = \{ v_1, v_2, ..., v_{m_1} \}, \quad v_i \in \mathcal{U}
  $$
* **P2**：

  $$
  W = \{ (w_j, t_j) \}, \quad w_j \in \mathcal{U},\ t_j \in \mathbb{Z}^+
  $$

---

### 4. 协议执行流程

#### 4.1 Setup 阶段

1. P1、P2 分别选择私钥指数 $k_1, k_2$
2. P2 生成加法同态加密密钥对 $(pk, sk)$

#### 4.2 Round 1（P1 → P2）

1. P1 对每个 $v_i$：计算 $H(v_i)^{k_1}$
2. 打乱顺序后发送给 P2

#### 4.3 Round 2（P2 → P1）

1. P2 对收到的 $H(v_i)^{k_1}$：计算 $H(v_i)^{k_1 k_2}$，打乱记为集合 $Z$
2. 对自身数据：

   * 计算 $H(w_j)^{k_2}$
   * 加密 $t_j$ 得到 $AEnc(t_j)$
   * 构造对 $(H(w_j)^{k_2}, AEnc(t_j))$
3. 打乱顺序后发送给 P1

#### 4.4 Round 3（P1 → P2）

1. P1 对每个 $H(w_j)^{k_2}$：计算 $H(w_j)^{k_1 k_2}$
2. 与集合 $Z$ 比对，找出交集索引集合 $J$
3. 对交集对应的 $AEnc(t_j)$ 进行同态加法，得到：

   $$
   AEnc(S_J) = AEnc\left(\sum_{j \in J} t_j\right)
   $$
4. 使用随机化算法 $ARefresh$ 重新随机化密文
5. 将结果发送给 P2

#### 4.5 Output 阶段（P2 解密）

* P2 用 $sk$ 解密，得到交集总和 $S_J$

---

### 5. 隐私保证分析

#### 对 P1 的保护

* P2 无法得知 $V$ 中哪些元素与 $W$ 匹配
* 所有元素均为随机群元素，且乱序发送

#### 对 P2 的保护

* P1 只能看到加密的 $t_j$，无解密能力
* 非交集部分的 $t_j$ 不会被用于累加

#### 总体泄露信息

* 仅泄露交集大小及交集 $t_j$ 的总和
* 不暴露具体交集元素

---

### 6. 实验结果

详见 **project6.png**

---

### 7. 实验总结

该协议在 **强隐私保护前提下** 实现了集合交集求和，安全性基于 DDH 与加法同态加密，适合多种实际应用场景。

---
